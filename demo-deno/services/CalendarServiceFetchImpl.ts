// Generated by RSD - Do not modify
import { ifDefined, safeExecute, type ServiceProps } from './_fetch-type-utils.ts';
import { api } from '../index.ts';

export function createCalendarService(props: ServiceProps<api.service.ErrorType>): api.service.CalendarService {
	return {
		create: fnCreate(props),
		get: fnGet(props),
		update: fnUpdate(props),
		eventView: fnEventView(props),
	};
}
function fnCreate(props: ServiceProps<api.service.ErrorType>): api.service.CalendarService['create'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onError, onCatch, final } = lifecycleHandlers;
	return async (calendar: api.model.CalendarNew) => {
		try {
			const $init = (await preFetch?.('create')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/calendar/`;
			const $body = JSON.stringify(api.model.CalendarNewToJSON(calendar));
			const $response = await fetchAPI($path, { ...$init, method: 'POST', body: $body });
			if($response.status === 201) {
				const $data = await $response.json();
				return safeExecute(api.result.OK($data), () => onSuccess?.('create', $data));
			} else if($response.status === 422) {
				const err = {
					_type: 'InvalidContent',
					message: await $response.text(),
				} as const;
				return safeExecute(api.result.ERR(err), () => onError?.('create', err));
			}
			const err = { _type: '_Status', message: $response.statusText, status: $response.status, } as const;
			return api.result.ERR(err);
		} catch(e) {
			onCatch?.('create', e)
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee, } as const;
			return api.result.ERR(err);
		} finally {
			final?.('create');
		}
	};
}

function fnGet(props: ServiceProps<api.service.ErrorType>): api.service.CalendarService['get'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onError, onCatch, final } = lifecycleHandlers;
	return async (key: string) => {
		try {
			const $init = (await preFetch?.('get')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/calendar/${key}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if($response.status === 200) {
				const $data = await $response.json();
				const $result = api.model.CalendarFromJSON($data);
				return safeExecute(api.result.OK($result), () => onSuccess?.('get', $result));
			} else if($response.status === 404) {
				const err = {
					_type: 'NotFound',
					message: await $response.text(),
				} as const;
				return safeExecute(api.result.ERR(err), () => onError?.('get', err));
			} else if($response.status === 400) {
				const err = {
					_type: 'InvalidArgument',
					message: await $response.text(),
				} as const;
				return safeExecute(api.result.ERR(err), () => onError?.('get', err));
			}
			const err = { _type: '_Status', message: $response.statusText, status: $response.status, } as const;
			return api.result.ERR(err);
		} catch(e) {
			onCatch?.('get', e)
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee, } as const;
			return api.result.ERR(err);
		} finally {
			final?.('get');
		}
	};
}

function fnUpdate(props: ServiceProps<api.service.ErrorType>): api.service.CalendarService['update'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onError, onCatch, final } = lifecycleHandlers;
	return async (key: string, changes: api.model.Calendar) => {
		try {
			const $init = (await preFetch?.('update')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			$init.headers = $headers;

			const $path = `${baseUrl}/api/calendar/${key}`;
			const $body = JSON.stringify(api.model.CalendarPatchToJSON(changes));
			const $response = await fetchAPI($path, { ...$init, method: 'PATCH', body: $body });
			if($response.status === 204) {
				return safeExecute(api.result.OK(api.result.Void), () => onSuccess?.('update', api.result.Void));
			} else if($response.status === 404) {
				const err = {
					_type: 'NotFound',
					message: await $response.text(),
				} as const;
				return safeExecute(api.result.ERR(err), () => onError?.('update', err));
			} else if($response.status === 400) {
				const err = {
					_type: 'InvalidArgument',
					message: await $response.text(),
				} as const;
				return safeExecute(api.result.ERR(err), () => onError?.('update', err));
			}
			const err = { _type: '_Status', message: $response.statusText, status: $response.status, } as const;
			return api.result.ERR(err);
		} catch(e) {
			onCatch?.('update', e)
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee, } as const;
			return api.result.ERR(err);
		} finally {
			final?.('update');
		}
	};
}

function fnEventView(props: ServiceProps<api.service.ErrorType>): api.service.CalendarService['eventView'] {
	const { baseUrl, fetchAPI = fetch, lifecycleHandlers = {} } = props;
	const { preFetch, onSuccess, onError, onCatch, final } = lifecycleHandlers;
	return async (key: string, start: string, end: string, timezone: string, resultTimeZone?: string) => {
		try {
			const $init = (await preFetch?.('eventView')) ?? {};
			const $headers = new Headers($init.headers ?? {});
			$headers.append('Content-Type', 'application/json');
			ifDefined(resultTimeZone, v => $headers.append('resultTimeZone',`${v}`));
			$init.headers = $headers;

			const $param = new URLSearchParams();
			$param.append('from', `${start}`);
			$param.append('to', `${end}`);
			$param.append('timezone', `${timezone}`);
			const $path = `${baseUrl}/api/calendar/${key}/view?${$param.toString()}`;
			const $response = await fetchAPI($path, { ...$init, method: 'GET' });

			if($response.status === 200) {
				const $data = await $response.json();
				if(!api.utils.isArray) {
					throw new Error('Invalid result');
				}
				const $result = $data.map(api.model.EventViewFromJSON);
				return safeExecute(api.result.OK($result), () => onSuccess?.('eventView', $result));
			} else if($response.status === 404) {
				const err = {
					_type: 'NotFound',
					message: await $response.text(),
				} as const;
				return safeExecute(api.result.ERR(err), () => onError?.('eventView', err));
			} else if($response.status === 400) {
				const err = {
					_type: 'InvalidArgument',
					message: await $response.text(),
				} as const;
				return safeExecute(api.result.ERR(err), () => onError?.('eventView', err));
			}
			const err = { _type: '_Status', message: $response.statusText, status: $response.status, } as const;
			return api.result.ERR(err);
		} catch(e) {
			onCatch?.('eventView', e)
			const ee = e instanceof Error ? e : new Error('', { cause: e });
			const err = { _type: '_Native', message: ee.message, error: ee, } as const;
			return api.result.ERR(err);
		} finally {
			final?.('eventView');
		}
	};
}

